This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-18T16:37:28.769Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
index.html
package.json
README.md
src/app.js
src/controllers/adminController.js
src/controllers/authController.js
src/controllers/bookingController.js
src/controllers/driverController.js
src/controllers/userController.js
src/controllers/vehicleController.js
src/middleware/adminMiddleware.js
src/middleware/authMiddleware.js
src/middleware/errorHandler.js
src/middleware/loggingMiddleware.js
src/models/Booking.js
src/models/Driver.js
src/models/User.js
src/models/Vehicle.js
src/routes/adminRoutes.js
src/routes/authRouter.js
src/routes/bookingRoutes.js
src/routes/driverRoutes.js
src/routes/userRoutes.js
src/routes/vehicleRoutes.js
src/services/jobAssignment.js
src/services/matchingService.js
src/services/pricingService.js
src/services/schedulerService.js
src/services/trackingService.js
src/websockets/trackingSocket.js
test.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Ignore node_modules directory
node_modules/

# Ignore environment variable files
.env

# Ignore log files
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Ignore lock files (if you're using npm, not yarn)
package-lock.json

# Ignore compiled output
dist/
build/

# Ignore VSCode settings
.vscode/

# Ignore temporary files
*.tmp
*.log
.DS_Store
Thumbs.db

# Ignore test coverage directory
coverage/

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>
<body>
    <h1>WebSocket Test</h1>
    <div>
        <input type="text" id="email" placeholder="Email">
        <input type="password" id="password" placeholder="Password">
        <button id="login">Login</button>
    </div>
    <button id="connect">Connect</button>
    <button id="subscribe">Subscribe to Booking</button>
    <button id="updateLocation">Update Location</button>
    <button id="getLocation">Get Location</button>
    <div id="output"></div>

    <script>
        let token = '';
        const socket = io('https://fleet-track-dynamics-atlan-production.up.railway.app');
        const bookingId = '670d6ad9a607f1c283889d5c'; // Use the booking ID from your test

        document.getElementById('login').addEventListener('click', async () => {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                const response = await apiCall('api/v2/auth/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password }),
                });
                const data = await response.json();
                if (data.success) {
                    token = data.token;
                    log('Login successful. Token received: ' + token);
                } else {
                    log('Login failed: ' + data.message);
                }
            } catch (error) {
                log('Login error: ' + error.message);
            }
        });

        document.getElementById('connect').addEventListener('click', () => {
            if (!token) {
                log('Please login first');
                return;
            }
            socket.io.opts.extraHeaders = {
                Authorization: `Bearer ${token}`
            };
            socket.connect();
            log('Connected to WebSocket');
        });

        document.getElementById('subscribe').addEventListener('click', () => {
            if (!token) {
                log('Please login first');
                return;
            }
            socket.emit('subscribe', bookingId);
            log('Subscribed to booking: ' + bookingId);
        });

        document.getElementById('updateLocation').addEventListener('click', async () => {
            if (!token) {
                log('Please login first');
                return;
            }
            const location = { lat: Math.random() * 90, lng: Math.random() * 180 };
            try {
                const response = await apiCall(`api/v2/bookings/${bookingId}/location`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(location),
                });
                const data = await response.json();
                log('Location updated: ' + JSON.stringify(location));
                log('Server response: ' + JSON.stringify(data));
            } catch (error) {
                log('Update location error: ' + error.message);
            }
        });

        document.getElementById('getLocation').addEventListener('click', async () => {
            if (!token) {
                log('Please login first');
                return;
            }
            try {
                const response = await apiCall(`api/v2/bookings/${bookingId}/location`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const data = await response.json();
                log('Current location: ' + JSON.stringify(data.location));
            } catch (error) {
                log('Get location error: ' + error.message);
            }
        });

        socket.on('locationUpdate', (location) => {
            log('Received location update: ' + JSON.stringify(location));
        });

        function log(message) {
            const output = document.getElementById('output');
            output.innerHTML += message + '<br>';
        }
    </script>
</body>
</html>

================
File: package.json
================
{
  "name": "atlan-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon src/app.js",
    "dev": "nodemon src/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-async-handler": "^1.2.0",
    "ioredis": "^5.4.1",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "moment": "^2.30.1",
    "mongoose": "^8.7.1",
    "node": "^20.18.0",
    "node-cron": "^3.0.3",
    "redis": "^4.7.0",
    "repopack": "^0.1.42",
    "socket.io": "^4.8.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.7"
  }
}

================
File: README.md
================
# Project Structure
backend/
│
├── src/
│   ├── config/
│   │   ├── database.js
│   │   ├── environment.js
│   │   └── redis.js
│   │
│   ├── controllers/
│   │   ├── authController.js
│   │   ├── userController.js
│   │   ├── driverController.js
│   │   ├── bookingController.js
│   │   ├── vehicleController.js
│   │   ├── trackingController.js
│   │   ├── pricingController.js
│   │   └── adminController.js
│   │
│   ├── models/
│   │   ├── User.js
│   │   ├── Driver.js
│   │   ├── Booking.js
│   │   ├── Vehicle.js
│   │   ├── Location.js
│   │   └── Payment.js
│   │
│   ├── routes/
│   │   ├── authRoutes.js
│   │   ├── userRoutes.js
│   │   ├── driverRoutes.js
│   │   ├── bookingRoutes.js
│   │   ├── vehicleRoutes.js
│   │   ├── trackingRoutes.js
│   │   ├── pricingRoutes.js
│   │   └── adminRoutes.js
│   │
│   ├── middleware/
│   │   ├── authMiddleware.js
│   │   ├── errorHandler.js
│   │   ├── validation.js
│   │   └── rateLimiter.js
│   │
│   ├── services/
│   │   ├── bookingService.js
│   │   ├── pricingService.js
│   │   ├── matchingService.js
│   │   ├── trackingService.js
│   │   ├── notificationService.js
│   │   └── analyticsService.js
│   │
│   ├── utils/
│   │   ├── logger.js
│   │   ├── apiResponse.js
│   │   ├── geocoding.js
│   │   └── distanceCalculator.js
│   │
│   ├── websockets/
│   │   ├── trackingSocket.js
│   │   └── notificationSocket.js
│   │
│   ├── jobs/
│   │   ├── cleanupJob.js
│   │   └── analyticsJob.js
│   │
│   └── app.js
│
├── tests/
│   ├── unit/
│   └── integration/
│
├── scripts/
│   ├── seed.js
│   └── deploy.sh
│
├── .env
├── .gitignore
├── package.json
└── README.md

================
File: src/app.js
================
const cors = require('cors');
const dotenv = require("dotenv");
const express = require('express');
const mongoose = require('mongoose');
const cookieParser = require('cookie-parser');
const authRouter = require('./routes/authRouter');
const userRouter = require('./routes/userRoutes');
const driverRouter = require('./routes/driverRoutes');
const vehicleRouter = require('./routes/vehicleRoutes');
const bookingRouter = require('./routes/bookingRoutes');
const adminRouter = require('./routes/adminRoutes');
const errorHandler = require('./middleware/errorHandler');
const loggingMiddleware = require('./middleware/loggingMiddleware');
const schedulerService = require('./services/schedulerService');


const PORT = process.env.PORT || 3001;
const http = require('http');
const setupWebSocket = require('./websockets/trackingSocket');

require('dotenv').config({ path: './.env' });

console.log('REDIS_URL:', process.env.REDIS_URL);
console.log('MONGO_URL:', process.env.MONGO_URL);
console.log('JWT_SECRET:', process.env.JWT_SECRET);

const app = express();
const server = http.createServer(app);
const io = setupWebSocket(server);
schedulerService.init();



app.use(express.json());
app.use(cookieParser());
app.use(cors());
app.use(loggingMiddleware);

app.use("/api/v2/auth", authRouter);
app.use("/api/v2/users", userRouter);
app.use("/api/v2/drivers", driverRouter);
app.use("/api/v2/vehicles", vehicleRouter);
app.use("/api/v2/bookings", bookingRouter);
app.use("/api/v2/admin", adminRouter);

app.use(errorHandler);

app.get('/', (req, res) => {
  res.send(`
    <h1>Server has started and API is Working</h1>
    <p>Refer to the Postman Docs here: <a href="https://documenter.getpostman.com/view/37397155/2sA3rwLDt1">Postman Documentation</a></p>
  `);
});

const mongoDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URL);
    console.log("MongoDB Database connected Successfully!");
  } catch (err) {
    console.log("Failed to connect to MongoDB:", err);
    throw err;
  }
}

app.listen(PORT, () => {
  mongoDB();
  console.log(`Server is running on http://localhost:${PORT}`);
});

module.exports = { app, io };

================
File: src/controllers/adminController.js
================
// src/controllers/adminController.js

const User = require('../models/User');
const Booking = require('../models/Booking');
const Vehicle = require('../models/Vehicle');

exports.getDashboard = async (req, res) => {
  try {
    const userCount = await User.countDocuments();
    const driverCount = await User.countDocuments({ role: 'driver' });
    const bookingCount = await Booking.countDocuments();
    const vehicleCount = await Vehicle.countDocuments();

    res.json({
      success: true,
      data: {
        userCount,
        driverCount,
        bookingCount,
        vehicleCount
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching dashboard data', error: error.message });
  }
};

exports.getStatistics = async (req, res) => {
  try {
    const completedRides = await Booking.countDocuments({ status: 'completed' });
    const cancelledRides = await Booking.countDocuments({ status: 'cancelled' });
    const totalRevenue = await Booking.aggregate([
      { $match: { status: 'completed' } },
      { $group: { _id: null, total: { $sum: '$price' } } }
    ]);

    res.json({
      success: true,
      data: {
        completedRides,
        cancelledRides,
        totalRevenue: totalRevenue[0]?.total || 0
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching statistics', error: error.message });
  }
};

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.json({ success: true, data: users });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching users', error: error.message });
  }
};

exports.getAllDrivers = async (req, res) => {
  try {
    const drivers = await User.find({ role: 'driver' }).select('-password');
    res.json({ success: true, data: drivers });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching drivers', error: error.message });
  }
};

exports.getAllVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find().populate('driver', '-password');
    res.json({ success: true, data: vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
  }
};


exports.getDriverActivity = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    const query = { role: 'driver' };
    if (startDate && endDate) {
      query.createdAt = { $gte: new Date(startDate), $lte: new Date(endDate) };
    }

    const drivers = await User.find(query).select('-password');
    const driverIds = drivers.map(driver => driver._id);

    const bookings = await Booking.find({
      driver: { $in: driverIds },
      createdAt: query.createdAt
    });

    const driverActivity = drivers.map(driver => {
      const driverBookings = bookings.filter(booking => booking.driver.toString() === driver._id.toString());
      return {
        driverId: driver._id,
        name: driver.username,
        totalBookings: driverBookings.length,
        completedBookings: driverBookings.filter(booking => booking.status === 'completed').length,
        cancelledBookings: driverBookings.filter(booking => booking.status === 'cancelled').length,
        totalRevenue: driverBookings.reduce((sum, booking) => sum + (booking.price || 0), 0)
      };
    });

    res.json({ success: true, data: driverActivity });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching driver activity', error: error.message });
  }
};

exports.getBookingData = async (req, res) => {
  try {
    const { startDate, endDate, status, page = 1, limit = 10 } = req.query;
    const query = {};
    if (startDate && endDate) {
      query.createdAt = { $gte: new Date(startDate), $lte: new Date(endDate) };
    }
    if (status) {
      query.status = status;
    }

    const totalBookings = await Booking.countDocuments(query);
    const totalPages = Math.ceil(totalBookings / limit);

    const bookings = await Booking.find(query)
      .populate('user', 'username')
      .populate('driver', 'username')
      .populate('vehicle', 'make model')
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(Number(limit));

    res.json({
      success: true,
      data: bookings,
      pagination: {
        currentPage: Number(page),
        totalPages,
        totalBookings,
        limit: Number(limit)
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching booking data', error: error.message });
  }
};

exports.getRevenueAnalytics = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    const query = { status: 'completed' };
    if (startDate && endDate) {
      query.createdAt = { $gte: new Date(startDate), $lte: new Date(endDate) };
    }

    const revenueData = await Booking.aggregate([
      { $match: query },
      {
        $group: {
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
          totalRevenue: { $sum: "$price" },
          bookingCount: { $sum: 1 }
        }
      },
      { $sort: { _id: 1 } }
    ]);

    res.json({ success: true, data: revenueData });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching revenue analytics', error: error.message });
  }
};

module.exports = exports;

================
File: src/controllers/authController.js
================
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

exports.signup = async (req, res) => {
  try {
    const { username, email, password, role, licenseNumber, experienceYears } = req.body;
    
    if (role === 'driver' && (!licenseNumber || !experienceYears)) {
      return res.status(400).json({ success: false, message: 'License number and experience years are required for drivers' });
    }

    const user = new User({ 
      username, 
      email, 
      password, 
      role,
      ...(role === 'driver' && { licenseNumber, experienceYears })
    });
    
    await user.save();
    
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.status(201).json({ 
      success: true, 
      token,
      user: { 
        id: user._id, 
        username: user.username, 
        email: user.email,
        role: user.role
      } 
    });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.status(200).json({ 
      success: true, 
      token, 
      user: { 
        id: user._id, 
        username: user.username, 
        email: user.email,
        role: user.role  // Include the role in the response
      } 
    });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
};

exports.logout = (req, res) => {
  res.status(200).json({ success: true, message: 'Logged out successfully' });
};

exports.getMe = async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findById(userId).select('-password');

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.status(200).json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        role: user.role  // Include the role here as well
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching user data', error: error.message });
  }
};

================
File: src/controllers/bookingController.js
================
const Booking = require('../models/Booking');
const User = require('../models/User');
const Vehicle = require('../models/Vehicle');
const trackingService = require('../services/trackingService');
const pricingService = require('../services/pricingService');
const redisClient = require('../config/redis');
const { findMatchingDriver } = require('../services/matchingService');
const mongoose = require('mongoose');

exports.getAllBookings = async (req, res) => {
  try {
    const bookings = await Booking.find()
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');
    res.status(200).json({ success: true, bookings });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching bookings', error: error.message });
  }
};



exports.getUserBookings = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ success: false, message: 'User email is required' });
    }

    // Find the user by email first
    const user = await User.findOne({ email: email }).select('_id');
    console.log("User's bookings are :",user)
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Now find bookings for this user by _id
    const bookings = await Booking.find({ user: user._id })
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle')
      .sort({ createdAt: -1 }); // Sort by creation date, newest first

    res.status(200).json({ success: true, bookings });
  } catch (error) {
    console.error('Error fetching user bookings:', error);
    res.status(500).json({ success: false, message: 'Error fetching user bookings', error: error.message });
  }
};




exports.getBookingById = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Try to get the booking from cache
    const cachedBooking = await redisClient.get(`booking:${id}`);
    if (cachedBooking) {
      return res.status(200).json({ success: true, booking: JSON.parse(cachedBooking) });
    }

    // If not in cache, get from database
    const booking = await Booking.findById(id)
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');

    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    // Cache the booking for future requests
    await redisClient.set(`booking:${id}`, JSON.stringify(booking), 'EX', 3600); // Cache for 1 hour

    res.status(200).json({ success: true, booking });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching booking', error: error.message });
  }
};

exports.createFutureBooking = async (req, res) => {
  try {
    const { userId, driverId, vehicleId, pickup, dropoff, price: userProvidedPrice, scheduledTime } = req.body;

    console.log('Creating future booking with:', { userId, driverId, vehicleId, pickup, dropoff, userProvidedPrice, scheduledTime });

    if (new Date(scheduledTime) <= new Date()) {
      return res.status(400).json({ success: false, message: 'Scheduled time must be in the future' });
    }

    // Check if user exists
    const user = await User.findById(userId);
    if (!user) {
      console.log('User not found:', userId);
      return res.status(400).json({ success: false, message: 'Invalid user' });
    }

    // Check if driver exists
    const driver = await User.findOne({ _id: driverId });
    if (!driver) {
      console.log('Driver not found:', driverId);
      return res.status(400).json({ success: false, message: 'Invalid driver' });
    }

    // Check if vehicle exists and belongs to the driver
    const vehicle = await Vehicle.findOne({ _id: vehicleId, driver: driverId });
    if (!vehicle) {
      console.log('Vehicle not found or does not belong to driver:', vehicleId, driverId);
      return res.status(400).json({ success: false, message: 'Invalid vehicle or vehicle does not belong to the driver' });
    }

    // Calculate distance (placeholder)
    const distance = Math.sqrt(
      Math.pow(dropoff.coordinates.lat - pickup.coordinates.lat, 2) +
      Math.pow(dropoff.coordinates.lng - pickup.coordinates.lng, 2)
    ) * 111; // Rough conversion to kilometers

    const currentDemand = await pricingService.getCurrentDemand();
    const calculatedPrice = pricingService.calculatePrice(distance, vehicle.vehicleType, currentDemand);

    // Use the calculated price if no price was provided, otherwise use the provided price
    const finalPrice = userProvidedPrice || calculatedPrice;

    const booking = new Booking({
      user: userId,
      driver: driverId,
      vehicle: vehicleId,
      pickup: {
        address: pickup.address,
        coordinates: {
          lat: Number(pickup.coordinates.lat),
          lng: Number(pickup.coordinates.lng)
        }
      },
      dropoff: {
        address: dropoff.address,
        coordinates: {
          lat: Number(dropoff.coordinates.lat),
          lng: Number(dropoff.coordinates.lng)
        }
      },
      price: finalPrice,
      scheduledTime,
      status: 'scheduled'
    });

    await booking.save();
    console.log('Future booking saved:', booking);

    // Fetch the saved booking with populated fields
    const populatedBooking = await Booking.findById(booking._id)
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');

    console.log('Populated future booking:', populatedBooking);

    res.status(201).json({ success: true, booking: populatedBooking });
  } catch (error) {
    console.error('Error creating future booking:', error);
    res.status(400).json({ success: false, message: 'Error creating future booking', error: error.message });
  }
};


exports.updateBookingStatus = async (req, res) => {
  try {
    const { status } = req.body;
    const booking = await Booking.findByIdAndUpdate(
      req.params.id,
      { status },
      { new: true, runValidators: true }
    )
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');

    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    // If the booking is completed or cancelled, make the driver and vehicle available again
    if (status === 'completed' || status === 'cancelled') {
      await User.findByIdAndUpdate(booking.driver._id, { isAvailable: true });
      await Vehicle.findByIdAndUpdate(booking.vehicle._id, { isAvailable: true });
    }

    res.status(200).json({ success: true, booking });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating booking status', error: error.message });
  }
};

exports.deleteBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }
    
    // Make the driver and vehicle available again
    await User.findByIdAndUpdate(booking.driver, { isAvailable: true });
    await Vehicle.findByIdAndUpdate(booking.vehicle, { isAvailable: true });

    await Booking.findByIdAndDelete(req.params.id);

    res.status(200).json({ success: true, message: 'Booking deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting booking', error: error.message });
  }
};


const SPEED_KM_PER_HOUR = 60;
const UPDATE_INTERVAL_MS = 2 * 60 * 1000; // 2 minutes


function calculateNewPosition(lat, lng, distanceKm) {
  const earthRadiusKm = 6371;
  const degreesPerKm = 1 / earthRadiusKm;
  const newLat = lat + (distanceKm * degreesPerKm);
  const newLng = lng + (distanceKm * degreesPerKm) / Math.cos(lat * Math.PI / 180);
  return { lat: newLat, lng: newLng };
}

exports.startTracking = async (bookingId, io) => {
  const booking = await Booking.findById(bookingId);
  if (!booking) return;

  let currentLocation = booking.pickup.coordinates;
  const destination = booking.dropoff.coordinates;

  const updateInterval = setInterval(async () => {
    const distanceKm = (SPEED_KM_PER_HOUR / 30) * (UPDATE_INTERVAL_MS / 1000 / 60);
    currentLocation = calculateNewPosition(currentLocation.lat, currentLocation.lng, distanceKm);

    await trackingService.updateLocation(bookingId, currentLocation);
    if (global.io) {
      global.io.to(bookingId).emit('locationUpdate', currentLocation);
    } else {
      console.error('Socket.IO instance not available');
    }

    if (Math.abs(currentLocation.lat - destination.lat) < 0.0001 && 
        Math.abs(currentLocation.lng - destination.lng) < 0.0001) {
      clearInterval(updateInterval);
      await Booking.findByIdAndUpdate(bookingId, { status: 'completed' });
      if (global.io) {
        global.io.to(bookingId).emit('rideCompleted');
      }
    }
  }, UPDATE_INTERVAL_MS);

  return updateInterval;
};



exports.createBooking = async (req, res) => {
  try {
    const { userId, driverId, vehicleId, pickup, dropoff, price: userProvidedPrice } = req.body;

    console.log('Creating booking with:', { userId, driverId, vehicleId, pickup, dropoff, userProvidedPrice });

    // Check if user exists
    const user = await User.findById(userId);
    if (!user) {
      console.log('User not found:', userId);
      return res.status(400).json({ success: false, message: 'Invalid user' });
    }

    // Check if driver exists and is actually a driver
    const driver = await User.findOne({ _id: driverId });
    if (!driver) {
      console.log('Driver not found or not a driver:', driverId);
      return res.status(400).json({ success: false, message: 'Invalid driver' });
    }

    // Check if vehicle exists and belongs to the driver
    const vehicle = await Vehicle.findOne({ _id: vehicleId, driver: driverId });
    if (!vehicle) {
      console.log('Vehicle not found or does not belong to driver:', vehicleId, driverId);
      return res.status(400).json({ success: false, message: 'Invalid vehicle or vehicle does not belong to the driver' });
    }

    // Calculate distance (this is a placeholder, you'd use a real distance calculation service)
    const distance = Math.sqrt(
      Math.pow(dropoff.coordinates.lat - pickup.coordinates.lat, 2) +
      Math.pow(dropoff.coordinates.lng - pickup.coordinates.lng, 2)
    ) * 111; // Rough conversion to kilometers

    const currentDemand = await pricingService.getCurrentDemand();
    const calculatedPrice = pricingService.calculatePrice(distance, vehicle.vehicleType, currentDemand);

    // Use the calculated price if no price was provided, otherwise use the provided price
    const finalPrice = userProvidedPrice || calculatedPrice;

    console.log("Driver Id is : ", driverId);

    const booking = new Booking({
      user: userId,
      driver: driverId,
      vehicle: vehicleId,
     pickup: {
    address: pickup.address,
    coordinates: {
      lat: Number(pickup.coordinates.lat),
      lng: Number(pickup.coordinates.lng)
    }
  },
  dropoff: {
    address: dropoff.address,
    coordinates: {
      lat: Number(dropoff.coordinates.lat),
      lng: Number(dropoff.coordinates.lng)
    }
  },
      price: finalPrice,
      status: 'pending'
    });

    await booking.save();
    console.log('Booking saved:', booking);

    // const match = await findMatchingDriver(booking);

    // if (match) {
    //   booking.driver = match.driver._id;
    //   booking.vehicle = match.vehicle._id;
    //   booking.status = 'assigned';

    //   // Update driver and vehicle availability
    //   await User.findByIdAndUpdate(match.driver._id, { isAvailable: false });
    //   await Vehicle.findByIdAndUpdate(match.vehicle._id, { isAvailable: false });
    // }

    // Fetch the saved booking with populated fields
    const populatedBooking = await Booking.findById(booking._id)
      .populate('user', '-password')
      .populate('driver', '-password')
      .populate('vehicle');

    console.log('Populated booking:', populatedBooking);

    res.status(201).json({ success: true, booking: populatedBooking });
  } catch (error) {
    console.error('Error creating booking:', error);
    res.status(400).json({ success: false, message: 'Error creating booking', error: error.message });
  }
};


exports.matchDriver = async (req, res) => {
  try {
    const { userId, pickup } = req.body;
    console.log('Received match request:', { userId, pickup });

    if (!pickup || !pickup.coordinates || !pickup.coordinates.lat || !pickup.coordinates.lng) {
      return res.status(400).json({ success: false, message: 'Invalid pickup coordinates' });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(400).json({ success: false, message: 'Invalid user' });
    }

    const matchedDriver = await findMatchingDriver(pickup);

    if (matchedDriver) {
      res.status(200).json({ 
        success: true, 
        driver: {
          _id: matchedDriver._id,
          username: matchedDriver.username,
          currentLocation: matchedDriver.currentLocation
        }
      });
    } else {
      res.status(404).json({ success: false, message: 'No matching driver found. Check server logs for details.' });
    }
  } catch (error) {
    console.error('Error matching driver:', error);
    res.status(500).json({ success: false, message: 'Error matching driver', error: error.message });
  }
};


exports.getLocation = async (req, res) => {
  try {
    const { id } = req.params;
    const location = await trackingService.getLocation(id);
    if (!location) {
      return res.status(404).json({ success: false, message: 'Location not found' });
    }
    res.status(200).json({ success: true, location });
  } catch (error) {
    console.error('Error fetching location:', error);
    res.status(500).json({ success: false, message: 'Error fetching location', error: error.message });
  }
};

exports.updateLocation = async (req, res) => {
  try {
    const { id } = req.params;
    const { lat, lng } = req.body;
    await trackingService.updateLocation(id, { lat, lng });
    res.status(200).json({ success: true, message: 'Location updated successfully' });
  } catch (error) {
    console.error('Error updating location:', error);
    res.status(500).json({ success: false, message: 'Error updating location', error: error.message });
  }
};

module.exports = exports;

================
File: src/controllers/driverController.js
================
const User = require('../models/User');
const Booking = require('../models/Booking');

exports.getAllDrivers = async (req, res) => {
  try {
    const drivers = await User.find({ role: 'driver' }).select('-password');
    res.status(200).json({ success: true, drivers });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching drivers', error: error.message });
  }
};

exports.getDriverById = async (req, res) => {
  try {
    const driver = await User.findOne({ _id: req.params.id, role: 'driver' }).select('-password');
    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching driver', error: error.message });
  }
};

exports.createDriver = async (req, res) => {
  try {
    const { username, email, password, licenseNumber, experienceYears } = req.body;

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ success: false, message: 'User with this email already exists' });
    }

    const newDriver = new User({
      username,
      email,
      password,
      role: 'driver',
      licenseNumber,
      experienceYears
    });

    await newDriver.save();
    res.status(201).json({ success: true, driver: newDriver.toObject({ getters: true, versionKey: false }) });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error creating driver', error: error.message });
  }
};

exports.updateDriver = async (req, res) => {
  try {
    const { licenseNumber, experienceYears, isAvailable } = req.body;
    const driver = await User.findOneAndUpdate(
      { _id: req.params.id, role: 'driver' },
      { licenseNumber, experienceYears, isAvailable },
      { new: true, runValidators: true }
    ).select('-password');

    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating driver', error: error.message });
  }
};

exports.deleteDriver = async (req, res) => {
  try {
    const driver = await User.findOneAndDelete({ _id: req.params.id, role: 'driver' });
    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, message: 'Driver deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting driver', error: error.message });
  }
};

exports.updateDriverLocation = async (req, res) => {
  try {
    const { latitude, longitude } = req.body;
    const driver = await User.findOneAndUpdate(
      { _id: req.params.id, role: 'driver' },
      { 
        currentLocation: {
          type: 'Point',
          coordinates: [longitude, latitude]
        }
      },
      { new: true, runValidators: true }
    ).select('-password');

    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating driver location', error: error.message });
  }
};

exports.getDriverLocationByBookingId = async (req, res) => {
  try {
    const { id } = req.params;

    console.log('Received bookingId:', id);
    const booking = await Booking.findById(id).populate('driver', 'currentLocation');
    console.log('Found booking:', booking);
    
    
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    if (!booking.driver) {
      return res.status(404).json({ success: false, message: 'Driver not assigned to this booking' });
    }

    // Send back the driver's current location
    const driverLocation = booking.driver.currentLocation.coordinates;

    res.status(200).json({ success: true, driverLocation });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching driver location', error: error.message });
  }
};


exports.getAvailableDrivers = async (req, res) => {
  try {
    const drivers = await User.find({ role: 'driver', isAvailable: true }).select('-password');
    res.status(200).json({ success: true, drivers });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching available drivers', error: error.message });
  }
};

exports.updateDriverAvailability = async (req, res) => {
  try {
    const { isAvailable } = req.body;
    const driver = await User.findOneAndUpdate(
      { _id: req.params.id, role: 'driver' },
      { isAvailable },
      { new: true, runValidators: true }
    ).select('-password');

    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }
    res.status(200).json({ success: true, driver });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating driver availability', error: error.message });
  }
};

exports.getDriverBookings = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ success: false, message: 'Driver email is required' });
    }

    const driver = await User.findOne({ email: email, role: 'driver' });

    if (!driver) {
      return res.status(404).json({ success: false, message: 'Driver not found' });
    }

    const bookings = await Booking.find({ driver: driver._id })
      .populate('user', 'username email')
      .populate('vehicle', 'make model licensePlate')
      .sort({ createdAt: -1 });

    res.status(200).json({ success: true, bookings: bookings });
  } catch (error) {
    console.error('Error fetching driver bookings:', error);
    res.status(500).json({ success: false, message: 'Error fetching driver bookings', error: error.message });
  }
};

exports.updateJobStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const driverId = req.user.id;

    const booking = await Booking.findOne({ _id: id, driver: driverId });
    if (!booking) {
      return res.status(404).json({ success: false, message: 'Booking not found or not assigned to this driver' });
    }

    booking.status = status;
    await booking.save();

    if (status === 'completed') {
      await User.findByIdAndUpdate(driverId, { isAvailable: true });
    }

    res.status(200).json({ success: true, booking });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating job status', error: error.message });
  }
};

module.exports = exports;

================
File: src/controllers/userController.js
================
const User = require('../models/User');

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find().select('-password');
    res.status(200).json({ success: true, users });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching users', error: error.message });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id).select('-password');
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    res.status(200).json({ success: true, user });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching user', error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { username, email } = req.body;
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { username, email },
      { new: true, runValidators: true }
    ).select('-password');

    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    res.status(200).json({ success: true, user });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating user', error: error.message });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    res.status(200).json({ success: true, message: 'User deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting user', error: error.message });
  }
};

================
File: src/controllers/vehicleController.js
================
const Vehicle = require('../models/Vehicle');
const Driver = require('../models/Driver');
const User = require('../models/User');

exports.getAllVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find().populate('driver');
    res.status(200).json({ success: true, vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
  }
};

exports.getVehicleById = async (req, res) => {
  try {
    const vehicle = await Vehicle.findById(req.params.id).populate('driver');
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, vehicle });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching vehicle', error: error.message });
  }
};
exports.getVehiclesByDriver = async (req, res) => {
    try {
      const driverId = req.params.driverId;
  
      // Check if the driver exists
      const driver = await User.findOne({ _id: driverId, role: 'driver' });
      if (!driver) {
        return res.status(404).json({ success: false, message: 'Driver not found' });
      }
  
      // Find all vehicles associated with this driver
      const vehicles = await Vehicle.find({ driver: driverId });
  
      res.status(200).json({ success: true, vehicles });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Error fetching vehicles', error: error.message });
    }
  };
  
exports.createVehicle = async (req, res) => {
    try {
      const { driverId, make, model, year, licensePlate, vehicleType, capacity, color } = req.body;
  
      // Check if driver exists and is actually a driver
      const driver = await User.findOne({ _id: driverId, role: 'driver' });
      if (!driver) {
        return res.status(400).json({ success: false, message: 'Invalid driver' });
      }
  
      const vehicle = new Vehicle({
        driver: driverId,
        make,
        model,
        year,
        licensePlate,
        vehicleType,
        capacity,
        color
      });
  
      await vehicle.save();
      res.status(201).json({ success: true, vehicle });
    } catch (error) {
      res.status(400).json({ success: false, message: 'Error creating vehicle', error: error.message });
    }
  };

exports.updateVehicle = async (req, res) => {
  try {
    const vehicle = await Vehicle.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true }).populate('driver');
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, vehicle });
  } catch (error) {
    res.status(400).json({ success: false, message: 'Error updating vehicle', error: error.message });
  }
};

exports.deleteVehicle = async (req, res) => {
  try {
    const vehicle = await Vehicle.findByIdAndDelete(req.params.id);
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found' });
    }
    res.status(200).json({ success: true, message: 'Vehicle deleted successfully' });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error deleting vehicle', error: error.message });
  }
};

exports.getAvailableVehicles = async (req, res) => {
  try {
    const vehicles = await Vehicle.find({ isAvailable: true }).populate('driver');
    res.status(200).json({ success: true, vehicles });
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error fetching available vehicles', error: error.message });
  }
};

module.exports = exports;

================
File: src/middleware/adminMiddleware.js
================
const User = require('../models/User');

exports.isAdmin = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (user.role !== 'admin') {
      return res.status(403).json({ success: false, message: 'Access denied. Admin only.' });
    }
    next();
  } catch (error) {
    res.status(500).json({ success: false, message: 'Error checking admin status', error: error.message });
  }
};

================
File: src/middleware/authMiddleware.js
================
const jwt = require('jsonwebtoken');

const authentication = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '') || 
                  req.cookies.token ||
                  req.body.token;

    if (!token) {
      return res.status(401).json({ success: false, message: "Token Not Found" });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = decoded;
      next();
    } catch (err) {
      return res.status(401).json({ success: false, message: "Invalid token" });
    }
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: "Something went wrong while validating token",
    });
  }
};


module.exports = { authentication };

================
File: src/middleware/errorHandler.js
================
// src/middleware/errorHandler.js

const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Something went wrong';

  res.status(statusCode).json({
    success: false,
    error: {
      message: message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
};

module.exports = errorHandler;

================
File: src/middleware/loggingMiddleware.js
================
// src/middleware/loggingMiddleware.js

const loggingMiddleware = (req, res, next) => {
    const start = Date.now();
    res.on('finish', () => {
      const duration = Date.now() - start;
      console.log(`${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms`);
    });
    next();
  };
  
  module.exports = loggingMiddleware;

================
File: src/models/Booking.js
================
const mongoose = require('mongoose');

const bookingSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  driver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',  // or 'Driver' if you decide to use the separate Driver model
    required: true
  },
  vehicle: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vehicle',
    required: true
  },
  pickup: {
    address: { type: String, required: true },
    coordinates: {
      lat: { type: Number, required: true },
      lng: { type: Number, required: true }
    }
  },
  dropoff: {
    address: { type: String, required: true },
    coordinates: {
      lat: { type: Number, required: true },
      lng: { type: Number, required: true }
    }
  },
  status: {
    type: String,
    enum: ['scheduled','pending', 'assigned', 'en_route', 'goods_collected', 'completed', 'cancelled'],
    default: 'pending'
  },
  price: {
    type: Number,
    required: true
  },
  scheduledTime: {
    type: Date,
    required: false // Make it optional
  },
  startTime: Date,
  endTime: Date,
  createdAt: {
    type: Date,
    default: Date.now
  }
});

bookingSchema.index({ user: 1, createdAt: -1 });
bookingSchema.index({ driver: 1, status: 1 });
bookingSchema.index({ status: 1, createdAt: -1 });

module.exports = mongoose.model('Booking', bookingSchema);

================
File: src/models/Driver.js
================
const mongoose = require('mongoose');

const driverSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  licenseNumber: {
    type: String,
    required: true,
    unique: true
  },
  experienceYears: {
    type: Number,
    required: true
  },
  rating: {
    type: Number,
    default: 0,
    min: 0,
    max: 5
  },
  isAvailable: {
    type: Boolean,
    default: true
  },
  currentLocation: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

driverSchema.index({ currentLocation: '2dsphere' });

module.exports = mongoose.model('Driver', driverSchema);

================
File: src/models/User.js
================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, enum: ['customer', 'driver', 'admin'], default: 'customer' },
  // Fields for drivers
  licenseNumber: { type: String, unique: true, sparse: true },
  experienceYears: { type: Number },
  isAvailable: { type: Boolean, default: false },
  currentLocation: {
    type: {
      type: String,
      enum: ['Point'],
      default: 'Point'
    },
    coordinates: {
      type: [Number],
      default: [0, 0]
    }
  },
  // Common fields
  phoneNumber: { type: String },
  address: { type: String },
});

userSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

userSchema.index({ currentLocation: '2dsphere' });

userSchema.index({ role: 1, isAvailable: 1 });
userSchema.index({ 'currentLocation': '2dsphere' });

module.exports = mongoose.model('User', userSchema);

================
File: src/models/Vehicle.js
================
const mongoose = require('mongoose');

const vehicleSchema = new mongoose.Schema({
  driver: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Driver',
    required: true
  },
  make: {
    type: String,
    required: true
  },
  model: {
    type: String,
    required: true
  },
  year: {
    type: Number,
    required: true
  },
  licensePlate: {
    type: String,
    required: true,
    unique: true
  },
  vehicleType: {
    type: String,
    enum: ['sedan', 'suv', 'van', 'truck'],
    required: true
  },
  capacity: {
    type: Number,
    required: true
  },
  color: String,
  isAvailable: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('Vehicle', vehicleSchema);

================
File: src/routes/adminRoutes.js
================
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const { authentication } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/adminMiddleware');

router.use(authentication);
router.use(isAdmin);

router.get('/dashboard', adminController.getDashboard);
router.get('/statistics', adminController.getStatistics);
router.get('/users', adminController.getAllUsers);
router.get('/drivers', adminController.getAllDrivers);
router.get('/vehicles', adminController.getAllVehicles);
router.get('/driver-activity', adminController.getDriverActivity);
router.get('/booking-data', adminController.getBookingData);
router.get('/revenue-analytics', adminController.getRevenueAnalytics);

module.exports = router;

================
File: src/routes/authRouter.js
================
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authentication } = require('../middleware/authMiddleware');


router.post('/signup', authController.signup);
router.post('/login', authController.login);
router.get('/logout', authController.logout);
router.get('/me', authentication, authController.getMe);

module.exports = router;

================
File: src/routes/bookingRoutes.js
================
const express = require('express');
const router = express.Router();
const bookingController = require('../controllers/bookingController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', bookingController.getAllBookings);
router.get('/:id', bookingController.getBookingById);
router.post('/', bookingController.createBooking);
router.post('/match', bookingController.matchDriver);
router.post('/userbookings', bookingController.getUserBookings);
router.put('/:id/status', bookingController.updateBookingStatus);
router.post('/future', bookingController.createFutureBooking);
router.delete('/:id', bookingController.deleteBooking);
router.post('/:id/track', bookingController.startTracking);
router.get('/:id/location', bookingController.getLocation);
router.post('/:id/location', bookingController.updateLocation);

module.exports = router;

================
File: src/routes/driverRoutes.js
================
const express = require('express');
const router = express.Router();
const driverController = require('../controllers/driverController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', driverController.getAllDrivers);
router.get('/available', driverController.getAvailableDrivers);
router.get('/:id', driverController.getDriverById);
router.post('/', driverController.createDriver);
// router.put('/:id', driverController.updateDriver);
router.post('/update-location/:id', driverController.updateDriverLocation);
// New route for getting driver's current location
router.get('/current-location/:id', driverController.getDriverLocationByBookingId);
router.put('/:id/availability', driverController.updateDriverAvailability);
// router.delete('/:id', driverController.deleteDriver);
router.post('/current-jobs', driverController.getDriverBookings);
router.put('/jobs/:id/status', driverController.updateJobStatus);

module.exports = router;

================
File: src/routes/userRoutes.js
================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { authentication } = require('../middleware/authMiddleware');

// Apply authentication middleware to all routes
router.use(authentication);

router.get('/', userController.getAllUsers);
router.get('/:id', userController.getUserById);
router.put('/:id', userController.updateUser);
router.delete('/:id', userController.deleteUser);

module.exports = router;

================
File: src/routes/vehicleRoutes.js
================
const express = require('express');
const router = express.Router();
const vehicleController = require('../controllers/vehicleController');
const { authentication } = require('../middleware/authMiddleware');

router.use(authentication);

router.get('/', vehicleController.getAllVehicles);
router.get('/available', vehicleController.getAvailableVehicles);
router.get('/:id', vehicleController.getVehicleById);
router.post('/', vehicleController.createVehicle);
router.put('/:id', vehicleController.updateVehicle);
router.delete('/:id', vehicleController.deleteVehicle);
router.get('/driver/:driverId', vehicleController.getVehiclesByDriver);
module.exports = router;

================
File: src/services/jobAssignment.js
================
// src/services/jobAssignmentService.js

const User = require('../models/User');

const assignDriver = async (booking) => {
  try {
    // Find available drivers near the pickup location
    const availableDrivers = await User.find({
      role: 'driver',
      isAvailable: true,
      currentLocation: {
        $near: {
          $geometry: {
            type: "Point",
            coordinates: [booking.pickup.coordinates.lng, booking.pickup.coordinates.lat]
          },
          $maxDistance: 10000 // 10km radius
        }
      }
    }).limit(1);

    if (availableDrivers.length > 0) {
      const assignedDriver = availableDrivers[0];
      assignedDriver.isAvailable = false;
      await assignedDriver.save();
      return assignedDriver;
    }

    return null;
  } catch (error) {
    console.error('Error assigning driver:', error);
    return null;
  }
};

module.exports = { assignDriver };

================
File: src/services/matchingService.js
================
// In services/matchingService.js

const User = require('../models/User');

const findMatchingDriver = async (pickup) => {
  try {
    console.log('Searching for nearest driver with pickup:', pickup);

    // Validate pickup coordinates
    if (!pickup.coordinates || !pickup.coordinates.lat || !pickup.coordinates.lng) {
      console.error('Invalid pickup coordinates:', pickup.coordinates);
      return null;
    }

    // Find the nearest driver
    const nearestDriver = await User.findOne({
      role: 'driver',
      currentLocation: {
        $near: {
          $geometry: {
            type: "Point",
            coordinates: [pickup.coordinates.lng, pickup.coordinates.lat]
          },
          $maxDistance: 1000000 // 10km radius
        }
      }
    }).sort({ 'currentLocation': 1 });

    if (!nearestDriver) {
      console.log('No driver found within 10km radius');
      return null;
    }

    console.log('Nearest driver found:', nearestDriver.username);
    console.log('Driver location:', nearestDriver.currentLocation);

    return nearestDriver;
  } catch (error) {
    console.error('Error in matching algorithm:', error);
    return null;
  }
};

module.exports = { findMatchingDriver };

================
File: src/services/pricingService.js
================
const moment = require('moment');

const calculatePrice = (distance, vehicleType, currentDemand, dateTime) => {
  const basePrice = 5;
  const pricePerKm = {
    'sedan': 1.5,
    'suv': 2,
    'van': 2.5,
    'truck': 3
  };

  // Time-based multiplier
  const hour = moment(dateTime).hour();
  let timeMultiplier = 1;
  if (hour >= 22 || hour < 6) {
    timeMultiplier = 1.5; // Night time surcharge
  } else if (hour >= 7 && hour < 10 || hour >= 16 && hour < 19) {
    timeMultiplier = 1.3; // Peak hours surcharge
  }

  // Day-based multiplier
  const day = moment(dateTime).day();
  const dayMultiplier = (day === 0 || day === 6) ? 1.2 : 1; // Weekend surcharge

  const demandMultiplier = 1 + (currentDemand / 100);

  const distancePrice = distance * (pricePerKm[vehicleType] || pricePerKm['sedan']);
  const totalPrice = (basePrice + distancePrice) * timeMultiplier * dayMultiplier * demandMultiplier;

  return Math.round(totalPrice * 100) / 100;
};

const getCurrentDemand = async () => {
  return Math.floor(Math.random() * 50); // Returns a random number between 0 and 50
};

module.exports = { calculatePrice, getCurrentDemand };

================
File: src/services/schedulerService.js
================
const cron = require('node-cron');
const Booking = require('../models/Booking');
const { assignDriver } = require('./jobAssignment');

const schedulerService = {
  init: () => {
    // Run every minute
    cron.schedule('* * * * *', async () => {
      try {
        const now = new Date();
        const fiveMinutesFromNow = new Date(now.getTime() + 5 * 60000);

        const upcomingBookings = await Booking.find({
          status: 'scheduled',
          scheduledTime: { $gte: now, $lt: fiveMinutesFromNow }
        });

        for (const booking of upcomingBookings) {
            booking.status = 'assigned';
            await booking.save();
        }
      } catch (error) {
            // Handle case when no driver is available
            booking.status = 'cancelled';
            await booking.save();
            // Notify user about cancellation
        console.error('Error processing scheduled bookings:', error);
      }
    });
  }
};

module.exports = schedulerService;

================
File: src/services/trackingService.js
================
const redisClient = require('../config/redis');

exports.updateLocation = async (bookingId, location) => {
  try {
    const key = `location:${bookingId}`;
    const value = JSON.stringify(location);
    await redisClient.set(key, value);
    console.log(`Updated location for ${key}: ${value}`);
  } catch (error) {
    console.error(`Error updating location for ${bookingId}:`, error);
    throw error;
  }
};

exports.getLocation = async (bookingId) => {
  try {
    const key = `location:${bookingId}`;
    const locationString = await redisClient.get(key);
    console.log(`Retrieved location for ${key}: ${locationString}`);
    return locationString ? JSON.parse(locationString) : null;
  } catch (error) {
    console.error(`Error getting location for ${bookingId}:`, error);
    throw error;
  }
};

module.exports = exports;

================
File: src/websockets/trackingSocket.js
================
// src/websockets/trackingSocket.js

const socketIo = require('socket.io');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Booking = require('../models/Booking');
const trackingService = require('../services/trackingService');

function setupWebSocket(server) {
  const io = socketIo(server);

  io.use(async (socket, next) => {
    if (socket.handshake.query && socket.handshake.query.token) {
      try {
        const decoded = jwt.verify(socket.handshake.query.token, process.env.JWT_SECRET);
        socket.userId = decoded.id;
        next();
      } catch (err) {
        next(new Error('Authentication error'));
      }
    } else {
      next(new Error('Authentication error'));
    }
  });

  io.on('connection', (socket) => {
    console.log('New client connected', socket.id);

    socket.on('subscribe', async (bookingId) => {
      try {
        const booking = await Booking.findById(bookingId);
        if (!booking) {
          socket.emit('error', 'Booking not found');
          return;
        }
        if (booking.user.toString() !== socket.userId && booking.driver.toString() !== socket.userId) {
          socket.emit('error', 'Unauthorized');
          return;
        }
        socket.join(bookingId);
        console.log(`Client ${socket.id} subscribed to booking ${bookingId}`);
      } catch (error) {
        console.error('Error in subscribe:', error);
        socket.emit('error', 'Server error');
      }
    });

    socket.on('updateLocation', async ({ bookingId, location }) => {
      try {
        const booking = await Booking.findById(bookingId);
        if (!booking) {
          socket.emit('error', 'Booking not found');
          return;
        }
        if (booking.driver.toString() !== socket.userId) {
          socket.emit('error', 'Unauthorized');
          return;
        }
        await trackingService.updateLocation(bookingId, location);
        io.to(bookingId).emit('locationUpdate', location);
        console.log(`Location updated for booking ${bookingId}: ${JSON.stringify(location)}`);
      } catch (error) {
        console.error('Error in updateLocation:', error);
        socket.emit('error', 'Server error');
      }
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected', socket.id);
    });
  });

  return io;
}

module.exports = setupWebSocket;

================
File: test.js
================
// // test-redis.js

// const redis = require('redis');

// const client = redis.createClient({
//   url: 'redis://localhost:6379'
// });

// client.on('error', (err) => console.log('Redis Client Error', err));
// client.on('connect', () => console.log('Redis Client Connected'));
// client.on('ready', () => console.log('Redis Client Ready'));

// async function testRedis() {
//   try {
//     await client.connect();
    
//     await client.set('testKey', 'Hello, Redis!');
//     const value = await client.get('testKey');
//     console.log('Retrieved value:', value);
//   } catch (error) {
//     console.error('Error:', error);
//   } finally {
//     await client.quit();
//   }
// }

// testRedis();


const fetch = require('node-fetch'); // Make sure to install node-fetch if not already installed

const API_KEY = 'AlzaSy3h_O_Xdl_y_uwhT5NDv3xwYzVvmgbvXvu'; // Replace with your actual API key

export const geocodeAddress1 = async (address) => {
  const encodedAddress = encodeURIComponent(address);
  const url = `https://maps.gomaps.pro/maps/api/geocode/json?address=${encodedAddress}&key=${API_KEY}`;

  console.log("Request URL:", url); // Log the request URL
  console.log("Using API Key:", API_KEY); // Log the API key

  try {
    const response = await apiCall(url);
    const data = await response.json();

    console.log("Geocode API response for:", address, data);

    if (data.status === 'OK' && data.results.length > 0) {
      const location = data.results[0].geometry.location;
      console.log("Geocoded location:", location);
      return { lat: location.lat, lng: location.lng };
    } else {
      console.error('Geocoding failed for:', address, 'Status:', data.status);
      throw new Error(`Geocoding failed for ${address}: ${data.status}`);
    }
  } catch (error) {
    console.error('Error during geocoding for:', address, error);
    throw error;
  }
};

(async () => {
  const address = "Bangalore Palace, Palace Cross Road, Vasanth Nagar, Bengaluru, Karnataka, India";
  try {
    const coords = await geocodeAddress1(address);
    console.log("Coordinates:", coords);
  } catch (error) {
    console.error("Failed to get coordinates:", error);
  }
})();
